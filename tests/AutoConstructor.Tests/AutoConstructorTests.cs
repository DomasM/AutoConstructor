using System.Text;
using System.Threading.Tasks;
using AutoConstructor.Generator;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using Xunit;
using VerifyCodeFix = AutoConstructor.Tests.Verifiers.CSharpCodeFixVerifier<
    AutoConstructor.Generator.ClassWithoutPartialAnalyzer,
    AutoConstructor.Generator.ClassWithoutPartialCodeFixProvider>;
using VerifySourceGenerator = AutoConstructor.Tests.Verifiers.CSharpSourceGeneratorVerifier<AutoConstructor.Generator.AutoConstructorGenerator>;

namespace AutoConstructor.Tests
{
    public class AutoConstructorTests
    {
        [Fact]
        public async Task Run_WithAttributeAndPartial_ShouldGenerateClass()
        {
            const string code = @"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        private readonly int _t;
    }
}";
            const string generated = @"// <auto-generated />
namespace Test
{
    partial class Test
    {
        public Test(int t)
        {
            this._t = t;
        }
    }
}
";
            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(AutoConstructorGenerator.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(AutoConstructorGenerator.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(AutoConstructorGenerator.InjectAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "Test.Test.g.cs", SourceText.From(generated, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Run_NoFieldsToInject_ShouldNotGenerateClass()
        {
            const string code = @"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
    }
}";
            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(AutoConstructorGenerator.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(AutoConstructorGenerator.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(AutoConstructorGenerator.InjectAttributeText, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Run_WithAttributeAndWithoutPartial_ShouldNotGenerateClass()
        {
            const string code = @"
namespace Test
{
    [AutoConstructor]
    internal class Test
    {
        private readonly int _t;
    }
}";

            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(AutoConstructorGenerator.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(AutoConstructorGenerator.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(AutoConstructorGenerator.InjectAttributeText, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Run_ClassWithoutNamespace_ShouldGenerateClass()
        {
            const string code = @"
[AutoConstructor]
internal partial class Test
{
    private readonly int _t;
}";
            const string generated = @"// <auto-generated />
partial class Test
{
    public Test(int t)
    {
        this._t = t;
    }
}
";

            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(AutoConstructorGenerator.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(AutoConstructorGenerator.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(AutoConstructorGenerator.InjectAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "Test.g.cs", SourceText.From(generated, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Analyzer_ClassWithoutPartial_ShouldReportDiagnostic()
        {
            const string test = @"
namespace Test
{
    [AutoConstructor]
    internal class {|#0:Test|}
    {
        private readonly int _t;
    }
}";

            // The two CS0246 are because the attribute is not known because the generator is not running.
            DiagnosticResult[] expected = new[] {
                VerifyCodeFix.Diagnostic("ACONS01").WithLocation(0),
                DiagnosticResult.CompilerError("CS0246").WithSpan(4, 6, 4, 21).WithArguments("AutoConstructor"),
                DiagnosticResult.CompilerError("CS0246").WithSpan(4, 6, 4, 21).WithArguments("AutoConstructorAttribute"),
            };
            await VerifyCodeFix.VerifyAnalyzerAsync(test, expected);
        }

        [Fact]
        public async Task CodeFix_ClassWithoutPartial_ShouldFixCode()
        {
            const string test = @"
namespace Test
{
    [AutoConstructor]
    internal class {|#0:Test|}
    {
        private readonly int _t;
    }
}";

            const string fixtest = @"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        private readonly int _t;
    }
}";

            // The two CS0246 are because the attribute is not known because the generator is not running.
            DiagnosticResult[] expected = new[] {
                VerifyCodeFix.Diagnostic("ACONS01").WithLocation(0),
                DiagnosticResult.CompilerError("CS0246").WithSpan(4, 6, 4, 21).WithArguments("AutoConstructor"),
                DiagnosticResult.CompilerError("CS0246").WithSpan(4, 6, 4, 21).WithArguments("AutoConstructorAttribute"),
            };
            await VerifyCodeFix.VerifyCodeFixAsync(test, expected, fixtest);
        }
    }
}
