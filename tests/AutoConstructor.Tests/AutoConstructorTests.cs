using System.Text;
using System.Threading.Tasks;
using AutoConstructor.Generator;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using Xunit;
using VerifyClassWithoutFieldsToInject = AutoConstructor.Tests.Verifiers.CSharpCodeFixVerifier<
    AutoConstructor.Generator.ClassWithoutFieldsToInjectAnalyzer,
    AutoConstructor.Generator.ClassWithoutFieldsToInjectCodeFixProvider>;
using VerifyClassWithoutPartial = AutoConstructor.Tests.Verifiers.CSharpCodeFixVerifier<
    AutoConstructor.Generator.ClassWithoutPartialAnalyzer,
    AutoConstructor.Generator.ClassWithoutPartialCodeFixProvider>;
using VerifySourceGenerator = AutoConstructor.Tests.Verifiers.CSharpSourceGeneratorVerifier<AutoConstructor.Generator.AutoConstructorGenerator>;

namespace AutoConstructor.Tests
{
    public class AutoConstructorTests
    {
        [Fact]
        public async Task Run_WithAttributeAndPartial_ShouldGenerateClass()
        {
            const string code = @"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        private readonly int _t;
    }
}";
            const string generated = @"// <auto-generated />
namespace Test
{
    partial class Test
    {
        public Test(int t)
        {
            this._t = t;
        }
    }
}
";
            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(Source.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(Source.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(Source.InjectAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "Test.Test.g.cs", SourceText.From(generated, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Run_WithInjectAttribute_ShouldGenerateClass()
        {
            const string code = @"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        [AutoConstructorInject(""guid.ToString()"", ""guid"", typeof(System.Guid))]
        private readonly string _guidString;
    }
}";
            const string generated = @"// <auto-generated />
namespace Test
{
    partial class Test
    {
        public Test(System.Guid guid)
        {
            this._guidString = guid.ToString() ?? throw new System.ArgumentNullException(nameof(guid));
        }
    }
}
";
            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(Source.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(Source.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(Source.InjectAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "Test.Test.g.cs", SourceText.From(generated, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Theory]
        [InlineData(@"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
    }
}")]
        [InlineData(@"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        [AutoConstructorIgnore]
        private readonly int _ignore;
    }
}")]
        [InlineData(@"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        private readonly int _ignore = 0;
    }
}")]
        [InlineData(@"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        private int _ignore;
    }
}")]
        public async Task Run_NoFieldsToInject_ShouldNotGenerateClass(string code)
        {
            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(Source.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(Source.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(Source.InjectAttributeText, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Run_WithAttributeAndWithoutPartial_ShouldNotGenerateClass()
        {
            const string code = @"
namespace Test
{
    [AutoConstructor]
    internal class Test
    {
        private readonly int _t;
    }
}";

            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(Source.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(Source.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(Source.InjectAttributeText, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Run_ClassWithoutNamespace_ShouldGenerateClass()
        {
            const string code = @"
[AutoConstructor]
internal partial class Test
{
    private readonly int _t;
}";
            const string generated = @"// <auto-generated />
partial class Test
{
    public Test(int t)
    {
        this._t = t;
    }
}
";

            await new VerifySourceGenerator.Test
            {
                TestState =
                {
                    Sources = { code },
                    GeneratedSources =
                    {
                        (typeof(AutoConstructorGenerator), "AutoConstructorAttribute.cs", SourceText.From(Source.AttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorIgnoreAttribute.cs", SourceText.From(Source.IgnoreAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "AutoConstructorInjectAttribute.cs", SourceText.From(Source.InjectAttributeText, Encoding.UTF8)),
                        (typeof(AutoConstructorGenerator), "Test.g.cs", SourceText.From(generated, Encoding.UTF8)),
                    }
                }
            }.RunAsync();
        }

        [Fact]
        public async Task Analyzer_ClassWithoutPartial_ShouldReportDiagnostic()
        {
            const string test = @"
namespace Test
{
    [AutoConstructor]
    internal class {|#0:Test|}
    {
        private readonly int _t;
    }
}";

            DiagnosticResult[] expected = new[] {
                VerifyClassWithoutPartial.Diagnostic("ACONS01").WithLocation(0),
            };
            await VerifyClassWithoutPartial.VerifyAnalyzerAsync(test, expected);
        }

        [Fact]
        public async Task CodeFix_ClassWithoutPartial_ShouldFixCode()
        {
            const string test = @"
namespace Test
{
    [AutoConstructor]
    internal class {|#0:Test|}
    {
        private readonly int _t;
    }
}";

            const string fixtest = @"
namespace Test
{
    [AutoConstructor]
    internal partial class Test
    {
        private readonly int _t;
    }
}";

            DiagnosticResult[] expected = new[] {
                VerifyClassWithoutPartial.Diagnostic("ACONS01").WithLocation(0),
            };
            await VerifyClassWithoutPartial.VerifyCodeFixAsync(test, expected, fixtest);
        }

        [Fact]
        public async Task Analyzer_ClassWithoutFieldsToInject_ShouldReportDiagnostic()
        {
            const string test = @"
namespace Test
{
    [{|#0:AutoConstructor|}]
    internal partial class Test
    {
    }
}";

            DiagnosticResult[] expected = new[] {
                VerifyClassWithoutFieldsToInject.Diagnostic("ACONS02").WithLocation(0),
            };
            await VerifyClassWithoutFieldsToInject.VerifyAnalyzerAsync(test, expected);
        }

        [Fact]
        public async Task Analyzer_ClassWithoutFieldsToInject_ShouldFixCode()
        {
            const string test = @"
namespace Test
{
    class TT
    {
    }

    [{|#0:AutoConstructor|}]
    internal partial class Test
    {
    }
}";
            const string fixtest = @"
namespace Test
{
    class TT
    {
    }

    internal partial class Test
    {
    }
}";

            DiagnosticResult[] expected = new[] {
                VerifyClassWithoutFieldsToInject.Diagnostic("ACONS02").WithLocation(0),
            };
            await VerifyClassWithoutFieldsToInject.VerifyCodeFixAsync(test, expected, fixtest);
        }
    }
}
