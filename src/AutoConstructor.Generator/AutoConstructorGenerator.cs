using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AutoConstructor.Generator
{
    [Generator]
    public class AutoConstructorGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            {
                return;
            }

            // Add attributes to context to be generated.
            context.AddSource(Source.AttributeFullName, SourceText.From(Source.AttributeText, Encoding.UTF8));
            context.AddSource(Source.IgnoreAttributeFullName, SourceText.From(Source.IgnoreAttributeText, Encoding.UTF8));
            context.AddSource(Source.InjectAttributeFullName, SourceText.From(Source.InjectAttributeText, Encoding.UTF8));

            // Add attributes to context to be able to be read with GetTypeByMetadataName on the compilation or to get constructor arguments.
            CSharpParseOptions? options = context.ParseOptions as CSharpParseOptions;
            Compilation compilation = context.Compilation
                .AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(Source.AttributeText, Encoding.UTF8), options))
                .AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(Source.IgnoreAttributeText, Encoding.UTF8), options))
                .AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(Source.InjectAttributeText, Encoding.UTF8), options));

            foreach (ClassDeclarationSyntax candidateClass in receiver.CandidateClasses)
            {
                if (context.CancellationToken.IsCancellationRequested)
                {
                    break;
                }

                SemanticModel model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
                INamedTypeSymbol? symbol = model.GetDeclaredSymbol(candidateClass);

                if (symbol is not null)
                {
                    string filename = $"{symbol.Name}.g.cs";
                    if (!symbol.ContainingNamespace.IsGlobalNamespace)
                    {
                        filename = $"{symbol.ContainingNamespace.ToDisplayString()}.{filename}";
                    }
                    string source = GenerateAutoConstructor(symbol);
                    if (!string.IsNullOrWhiteSpace(source))
                    {
                        context.AddSource(filename, SourceText.From(source, Encoding.UTF8));
                    }
                }
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver that will be created for each generation pass.
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        private static string GenerateAutoConstructor(INamedTypeSymbol symbol)
        {
            var fields = symbol.GetMembers().OfType<IFieldSymbol>()
                .Where(x => x.CanBeReferencedByName && !x.IsStatic && x.IsReadOnly && !x.IsInitialized() && !x.HasAttribute(Source.IgnoreAttributeFullName))
                .Select(GetFieldInfo)
                .ToList();

            if (fields.Count == 0)
            {
                return string.Empty;
            }

            var constructorParameters = fields.GroupBy(x => x.ParameterName).Select(x => x.First()).ToList();

            var source = new StringBuilder("// <auto-generated />");
            string tabulation = "    ";
            if (symbol.ContainingNamespace.IsGlobalNamespace)
            {
                tabulation = string.Empty;
            }
            else
            {
                source.Append($@"
namespace {symbol.ContainingNamespace.ToDisplayString()}
{{");
            }

            source.Append($@"
{tabulation}partial class {symbol.Name}
{tabulation}{{
{tabulation}    public {symbol.Name}({string.Join(", ", constructorParameters.Select(it => $"{it.Type} {it.ParameterName}"))})
{tabulation}    {{");

            foreach ((string type, string parameterName, string fieldName, string initializer) in fields)
            {
                source.Append($@"
{tabulation}        this.{fieldName} = {initializer};");
            }
            source.Append($@"
{tabulation}    }}
{tabulation}}}
");
            if (!symbol.ContainingNamespace.IsGlobalNamespace)
            {
                source.Append(@"}
");
            }

            return source.ToString();

            static (string Type, string ParameterName, string FieldName, string Initializer) GetFieldInfo(IFieldSymbol fieldSymbol)
            {
                ITypeSymbol type = fieldSymbol!.Type;
                string typeDisplay = type.ToDisplayString();
                string parameterName = fieldSymbol.Name.TrimStart('_');
                string initializer = parameterName;

                AttributeData? attributeData = fieldSymbol.GetAttribute(Source.InjectAttributeFullName);
                if (attributeData is not null)
                {
                    initializer = attributeData.ConstructorArguments[0].Value?.ToString() ?? "";
                    parameterName = attributeData.ConstructorArguments[1].Value?.ToString() ?? "";
                    typeDisplay = attributeData.ConstructorArguments[2].Value?.ToString() ?? "";
                }

                if (type.TypeKind == TypeKind.Class || type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
                {
                    initializer = $"{initializer} ?? throw new System.ArgumentNullException(nameof({parameterName}))";
                }

                return new(typeDisplay, parameterName, fieldSymbol!.Name, initializer);
            }
        }
    }
}
